<!DOCTYPE html>
<html>
  <head>
    <title>Gallery Program</title>
    <meta charset="utf-8" />
  </head>
  <body>

    <h1>Sit</h1>
    <h4>by Angelica Gao </h4>
    <img src="Sit.jpg" width="500" />
    <p> Sit. My interpretation of a the utility and vulnerability of the object. 
      Comprised of laser cut plywood that was purposefully double layered. 
    Bound together by the press fit joints and 4 screws. 
      Autodesk designed. Laser cut Fabrication. Manual Assembly and Polishing. 
    </p>

    <br/>
    <br/>
    <hr/>

    <h1>Repetition </h1>
    <h4>by Angelica Gao</h4>
    <img src="Repetition.png" width="500" />
    <p> Repetition. Textile Art Inspired by Magdelena Abakanowicz and Ruth Asawa. Forged on principles of reptition and endurance. 
    A transformative piece that responded to the medium. 
      An idea of repetition of individually looped segments. 
      With a final presentation on Abakan-inspired bodice. 
      Acrylic yarn. Handweaved. 
    </p>

    <br/>
    <br/>
    <hr/>

    <h1>Cube </h1>
    <h4>by Angelica Gao</h4>
    <img src="Cube.png" width="500" />
    <p> Cube. Iterative and interactive generative art. 
    Careful selection and random selection both merit randomness and unpredictability. 
    This piece is a commentary on the evolution of choice within a lifetime. 
    Confined within a societal frame. Guided within personal narratives. 
    Choose and then choose again, options become limited. 
      
    Created with AI collaboration, a user-interactive piece meant to be run on Processing. 
    Colors chosen to represent 4 elements of life: Water, Fire, Air, Earth. 
    
    Full Code: 
    
    int cols, rows, layers;
int numCubes = 1000;
float[][] positions;
color[] colors;
int currentCube = 0;

void setup() {
  size(800, 800, P3D);
  cols = 10;
  rows = 10;
  layers = 10;
  positions = new float[numCubes][3];
  colors = new color[numCubes];
  
  // Generate initial positions and colors for small cubes
  generateCubes();
  
  frameRate(60); // Faster frame rate for smoother animation
}

void draw() {
  background(0);
  lights();
  translate(width/2, height/2, -200);
  rotateX(frameCount * 0.01);
  rotateY(frameCount * 0.01);
  
  // Draw the funnel background
  drawFunnel();

  // Draw hollow main cube
  drawHollowCube(300);
  
  // Draw small cubes
  for (int i = 0; i < currentCube; i++) {
    fill(colors[i]);
    pushMatrix();
    translate(positions[i][0], positions[i][1], positions[i][2]);
    box(30);
    popMatrix();
  }
}

void mousePressed() {
  if (currentCube < numCubes) {
    // Map mouse position to the 3D space and add a new cube
    float x = map(mouseX, 0, width, -150, 150);
    float y = map(mouseY, 0, height, -150, 150);
    float z = random(-150, 150);

    positions[currentCube][0] = x;
    positions[currentCube][1] = y;
    positions[currentCube][2] = z;

    // Assign a random color representing an element
    int choice = int(random(4));
    if (choice == 0) {
      colors[currentCube] = color(0, 0, 255); // Water - Blue
    } else if (choice == 1) {
      colors[currentCube] = color(139, 69, 19); // Earth - Brown
    } else if (choice == 2) {
      colors[currentCube] = color(255, 255, 255); // Wind - White
    } else if (choice == 3) {
      colors[currentCube] = color(255, 0, 0); // Fire - Red
    }

    currentCube++;
  }
}

void generateCubes() {
  for (int i = 0; i < numCubes; i++) {
    // Randomly generate position within the hollow cube
    positions[i][0] = random(-150, 150);
    positions[i][1] = random(-150, 150);
    positions[i][2] = random(-150, 150);
    
    // Randomly assign a color representing water, earth, wind, fire
    int choice = int(random(4));
    if (choice == 0) {
      colors[i] = color(0, 0, 255); // Water - Blue
    } else if (choice == 1) {
      colors[i] = color(139, 69, 19); // Earth - Brown
    } else if (choice == 2) {
      colors[i] = color(255, 255, 255); // Wind - White
    } else if (choice == 3) {
      colors[i] = color(255, 0, 0); // Fire - Red
    }
  }
}

void drawHollowCube(float size) {
  stroke(255);
  noFill();
  
  // Top face
  beginShape();
  vertex(-size/2, -size/2, -size/2);
  vertex(size/2, -size/2, -size/2);
  vertex(size/2, size/2, -size/2);
  vertex(-size/2, size/2, -size/2);
  endShape(CLOSE);
  
  // Bottom face
  beginShape();
  vertex(-size/2, -size/2, size/2);
  vertex(size/2, -size/2, size/2);
  vertex(size/2, size/2, size/2);
  vertex(-size/2, size/2, size/2);
  endShape(CLOSE);
  
  // Connecting edges
  line(-size/2, -size/2, -size/2, -size/2, -size/2, size/2);
  line(size/2, -size/2, -size/2, size/2, -size/2, size/2);
  line(size/2, size/2, -size/2, size/2, size/2, size/2);
  line(-size/2, size/2, -size/2, -size/2, size/2, size/2);
}

void drawFunnel() {
  noFill();
  stroke(100, 100, 255, 150); // Light blue with some transparency

  beginShape();
  for (float z = -200; z < 200; z += 2) { // Smaller step size for smoother effect
    float radius = map(z, -200, 200, 150, 0);
    float x = cos(z * 0.05) * radius; // Slower rotation for smoother look
    float y = sin(z * 0.05) * radius;
    vertex(x, y, z);
  }
  endShape();
}

  </p>

  </body>
</html>
